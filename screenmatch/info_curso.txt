JUSTIFICAR TEXTO ALT + Z

****************************************************************

Comparación entre Maven y Gradle

Para entender la diferencia entre Maven y Gradle, primero necesitamos comprender qué son y para qué sirven. Maven y Gradle son herramientas de automatización de construcción y gestión de dependencias muy populares en la comunidad Java. Ayudan a simplificar y organizar el proceso de construcción, prueba e implementación de proyectos Java, haciendo que el desarrollo sea más eficiente.

¿Qué es Maven?

Principales conceptos de Maven:

Gestión de Dependencias: Maven es excelente para gestionar las dependencias de un proyecto. Las dependencias se declaran en el archivo pom.xml y Maven se encarga de descargarlas automáticamente desde el repositorio central de Maven o repositorios personalizados.

Convención sobre Configuración: Maven sigue un conjunto de convenciones, lo que significa que muchas configuraciones están predefinidas y se pueden utilizar directamente sin necesidad de configuración adicional.

Ciclo de Vida Estándar: Maven tiene un ciclo de vida estándar con diferentes fases (por ejemplo, compile, test, package, install, deploy), y cada fase ejecuta una serie de metas. El ciclo de vida estándar permite construir y probar fácilmente su proyecto mediante comandos como mvn compile, mvn test y mvn package.

Repositorio Central: Maven tiene un repositorio central que contiene una amplia variedad de bibliotecas Java listas para ser utilizadas. Este repositorio se puede visualizar en este enlace.

¿Qué es Gradle?

Gradle es otra herramienta de construcción y automatización de proyectos Java que ha ganado popularidad a lo largo de los años. Utiliza un lenguaje de dominio específico (DSL) basado en Groovy o Kotlin para definir la estructura del proyecto y las tareas de construcción.

Principales conceptos de Gradle:

Flexibilidad: Gradle es altamente flexible y le permite definir sus propias tareas de construcción y configurar el proceso de construcción según sus necesidades.

Construcción por Convención: Gradle también sigue algunas convenciones, pero ofrece más libertad que Maven en la forma en que organiza y configura el proyecto.

Gestión de Dependencias: Al igual que Maven, Gradle también gestiona las dependencias del proyecto y puede descargarlas de repositorios remotos.

Compilaciones Incrementales: Gradle está diseñado para realizar compilaciones incrementales, lo que significa que puede construir solo las partes del proyecto que han cambiado desde la última compilación, haciendo que el proceso sea más rápido.

Ahora que tenemos una comprensión básica de qué son Maven y Gradle, veamos sus similitudes, diferencias, ventajas y desventajas.

Similitudes

Tanto Maven como Gradle proporcionan convenciones para la estructura del directorio del proyecto, gestión de dependencias y complementos de construcción. También son ampliamente compatibles con IDEs y herramientas de Integración Continua (CI).

Diferencias

La principal diferencia entre Maven y Gradle es la forma en que gestionan las dependencias y cómo describen la lógica de construcción. Maven utiliza archivos XML para gestionar las dependencias y describe la lógica de construcción mediante complementos, mientras que Gradle utiliza un formato de script y describe la lógica de construcción como código.

Ventajas y Desventajas

Maven es fácil de aprender y tiene un gran ecosistema. La desventaja es que los archivos XML pueden volverse muy grandes y difíciles de gestionar para proyectos complejos.

Gradle, por otro lado, permite scripts de construcción más potentes y es más flexible. Sin embargo, es más difícil de aprender y su ecosistema aún no es tan grande como el de Maven.

La elección entre Maven y Gradle depende de tu proyecto y preferencias. Ambas herramientas son potentes y ampliamente utilizadas, y ambas tienen ventajas y desventajas. Maven es más rígido y sigue un enfoque "opinión sobre configuración", lo que puede ser una ventaja para proyectos más pequeños y simples. Por otro lado, Gradle es más flexible y personalizable, siendo una opción popular para proyectos más grandes y complejos que requieren configuraciones específicas.

En resumen, tanto Maven como Gradle pueden usarse eficientemente para proyectos Java, y la elección dependerá del contexto y las preferencias del equipo de desarrollo.


***************************************************************************************


La interfaz CommandLineRunner es un recurso poderoso dentro del universo de Spring Framework, ampliamente utilizado en el desarrollo de aplicaciones Java. Permite ejecutar alguna acción justo después de la inicialización de nuestra aplicación. Puede ser muy útil, por ejemplo, si queremos cargar algunos datos en nuestra base de datos justo al iniciar nuestra aplicación.

¿Cómo funciona?

Cuando se inicia una aplicación Spring Boot, pueden ocurrir varias operaciones automáticas, como la creación de beans, configuración de la base de datos, entre otras. La apertura para personalizar estas operaciones es limitada, y aquí es donde entra en juego la interfaz CommandLineRunner.

La interfaz CommandLineRunner representa una tarea que se ejecutará después de la inicialización de Spring Boot, es decir, permite definir código que se ejecutará automáticamente cuando se inicie la aplicación.

¿Cómo se usa?

La utilización es bastante simple. En la clase principal de la aplicación, podemos hacer que implemente la interfaz CommandLineRunner. Aquí tienes un ejemplo:

@SpringBootApplication
public class MyCommandLineRunner implements CommandLineRunner {
   
   @Override
    public void run(String... args) throws Exception {
        System.out.println("¡Hola, Mundo!");
    }
}
COPIA EL CÓDIGO
Observa que en el ejemplo anterior, creamos una clase llamada "MyCommandLineRunner" que implementa la interfaz CommandLineRunner. En el método "run", insertamos la acción que deseamos que se ejecute justo después de que la aplicación se inicie, en este caso, simplemente imprimimos "¡Hola, Mundo!".

¿Cuándo usar?

La interfaz CommandLineRunner es muy versátil y se puede utilizar en diversas situaciones. Como se mencionó anteriormente, se puede utilizar para cargar datos en una base de datos. También puede utilizarse para iniciar recursos, como conexiones de red, y para verificar la integridad de ciertos componentes o servicios con los que la aplicación va a interactuar.

Es importante recordar que CommandLineRunner se ejecuta solo en la inicialización de la aplicación, así que no debe utilizarse para tareas que deben ocurrir periódicamente durante el funcionamiento de la aplicación. Para eso, Spring ofrece otras herramientas que serán más adecuadas.

Motivación

Imaginemos una situación en la que tenemos que cargar una gran cantidad de datos en nuestra base de datos tan pronto como nuestra aplicación Spring inicie. Bueno, manualmente esto sería desafiante y llevaría mucho tiempo; sin embargo, la interfaz CommandLineRunner hace que esta tarea sea extremadamente más simple.

Al profundizar en tu conocimiento de Spring, tendrás diversas opciones para optimizar tus aplicaciones y hacer que tu código sea más limpio y eficaz. Spring es un framework que facilita el desarrollo de aplicaciones en Java. Ofrece un modelo de programación completo y simplificado, ocultando muchos de los detalles de bajo nivel. Como resultado, puedes concentrarte en escribir tu código sin preocuparte por una multitud de detalles técnicos. ¡Vamos a sumergirnos juntos en este conocimiento!



En el próximo video, vamos a consumir una API para buscar datos de series. Para hacer esto, crearemos la clase llamada ConsumoAPI dentro de un paquete llamado service. En esta clase, tendremos un método llamado obtenerDatos que devuelve una cadena de texto con el JSON correspondiente a la respuesta de la solicitud.

Dado que este procedimiento es muy similar al que se realizó en el último curso de la formación en Java Orientada a Objetos, lo dejaremos aquí ya disponible para que copies el código de este método y lo pegues en tu clase, con el objetivo de agilizar tus estudios. Sin embargo, si deseas regresar al curso anterior para revisar la explicación, haz clic para acceder al enlace de la lección.

public String obtenerDatos(String url) {
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .build();
        HttpResponse<String> response = null;
        try {
            response = client
                    .send(request, HttpResponse.BodyHandlers.ofString());
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        String json = response.body();
        return json;
    }


    ***************************************************************************************

    @JsonAlias y @JsonProperty son anotaciones de Jackson, una biblioteca Java para procesar JSON, que ayudan a mapear propiedades de clase a campos JSON.

Sin embargo, tienen funciones diferentes. ¿Vamos a conocer mejor cada una de estas anotaciones?

@JsonProperty

Esta anotación se utiliza para definir el nombre de la propiedad JSON asociada al campo Java.

Cuando el JSON se serializa, es decir, se convierte de objetos Java a JSON, el nombre especificado en @JsonProperty se utilizará como la clave para el campo en el JSON de salida. De manera similar, cuando el JSON se deserializa (se convierte de JSON a objetos Java), la biblioteca busca el nombre especificado en @JsonProperty para mapear el valor JSON al campo Java.

Entonces, si deseas usar un nombre diferente en el JSON, puedes utilizar @JsonProperty("nombreEnJson"). Esto es útil, por ejemplo, cuando necesitas trabajar con un JSON que sigue una convención de nomenclatura diferente a la de tu clase Java.

Por ejemplo, si tienes una clase Java con la propiedad "nombreCompleto" y deseas que se mapee al JSON como "nombre", puedes usar @JsonProperty("nombre") para especificar el nombre correcto en el JSON:

java
public class Persona {
    @JsonProperty("nombre")
    private String nombreCompleto;
}
COPIA EL CÓDIGO
@JsonAlias

@JsonAlias se utiliza para definir uno o más alias para el nombre de la propiedad JSON asociada al campo Java.

Al deserializar, @JsonAlias permite que la biblioteca encuentre el valor JSON correspondiente, incluso si el nombre de la propiedad en el JSON no coincide exactamente con el nombre del campo Java.

Esto es útil cuando trabajas con diferentes versiones de un JSON o cuando deseas permitir que una propiedad sea referenciada por nombres diferentes.

Por ejemplo, si tienes una clase Java con la propiedad "nombreCompleto" y el JSON usa "nombre" en su lugar, puedes usar @JsonAlias("nombre") para mapear correctamente la propiedad. De esta manera, tanto "nombreCompleto" como "nombre" serán aceptados al realizar el mapeo:

java
public class Persona {
    @JsonAlias({"nombreCompleto", "nombre"})
    private String nombreCompleto;
}
COPIA EL CÓDIGO
Para obtener más información sobre las anotaciones de Jackson, puedes consultar la documentación oficial aquí: Documentación de Jackson Annotations. https://github.com/FasterXML/jackson



********************************************************************************************

En Java, los genéricos permiten crear clases, interfaces y métodos que pueden trabajar con tipos desconocidos o parámetros genéricos. Proporcionan una forma de escribir código flexible y reutilizable, haciéndolo independiente de tipos específicos y permitiendo que funcione con diferentes tipos de datos.

Para crear una clase o método genérico, necesitas usar parámetros de tipo (tipos genéricos) que se representan entre corchetes angulares <>. Por lo general, usamos letras mayúsculas únicas para representar los tipos genéricos, pero puedes usar cualquier identificador válido en Java. Aquí tienes un ejemplo de una clase genérica llamada Caja, que almacena un valor de un tipo desconocido:

public class Caja<T> {
    private T contenido;

    public T getContenido() {
        return contenido;
    }

    public void setContenido(T contenido) {
        this.contenido = contenido;
    }
}
COPIA EL CÓDIGO
En el ejemplo anterior, podemos crear un objeto del tipo Caja y almacenar cualquier tipo de valor en él. Aquí tienes un ejemplo:

public class TesteaCaja {
    public static void main(String[] args) {
        Caja<String> cajaDeTexto = new Caja();
        cajaDeTexto.setContenido("Guardando texto en mi caja!");

        Caja<Integer> cajaDeEdad = new Caja();
        cajaDeEdad.setContenido(30);

        Caja<Double> cajaDeValor = new Caja<>();
        cajaDeValor.setContenido(150.50);
    }
}
COPIA EL CÓDIGO
Observa que podemos utilizar la clase Caja para incluir valores de diferentes tipos. Para la variable cajaDeTexto, el compilador garantizará que solo se puedan almacenar valores del tipo String. Para la variable cajaDeEdad, el compilador garantizará que solo se puedan almacenar valores del tipo Integer, y así sucesivamente.

Método Genérico

Para crear un método genérico, puedes usar la misma sintaxis con parámetros de tipo entre corchetes angulares. Aquí tienes un ejemplo de un método genérico, que pertenece a la clase Caja y que debería sumar el valor pasado por parámetro al contenido de la caja:

public <T> T sumaContenidoEnCaja(T valor) {
    if (this.contenido instanceof Integer c && valor instanceof Integer i) {
        Integer resultado = c + i;
        return (T) resultado;
    } else if (this.contenido instanceof Double c && valor instanceof Double d) {
        Double resultado = c + d;
        return (T) resultado;
    } else if (this.contenido instanceof String c && valor instanceof String s) {
        String resultado = c + "\n" + s;
        return (T) resultado;
    }

    return null;
}
COPIA EL CÓDIGO
La finalidad del método anterior es realizar la suma entre el contenido actual de la caja (this.contenido) y el valor pasado como parámetro (valor). El método es genérico y puede usarse para diferentes tipos de contenido que pueden sumarse, como Integer, Double y String.

Veamos paso a paso lo que sucede:

public <T> T sumaContenidoEnCaja(T valor) {

El método es genérico y recibe un parámetro valor del tipo genérico T, que es el mismo tipo que se devolverá como resultado de la suma.

Luego, el método comienza con una serie de condicionales if que verifican el tipo del contenido actual de la caja (this.contenido) y el tipo del valor pasado como parámetro (valor).

if (this.contenido instanceof Integer c && valor instanceof Integer i) {
    // Realiza la suma entre los valores y almacena el resultado en una variable
    Integer resultado = c + i;
    // Devuelve el resultado como tipo genérico `T` (en este caso, `Integer`)
    return (T) resultado;
}
COPIA EL CÓDIGO
La verificación se realiza utilizando los operadores instanceof y los operadores de coincidencia de patrones (instanceof con variables de patrón) disponibles a partir de Java 16.

Si el contenido actual (this.contenido) y el valor (valor) son ambos del mismo tipo, se realiza la suma o la concatenación, como en el caso de String. Si el tipo de la variable valor es diferente al tipo del contenido, devolvemos el valor anterior del contenido. Veamos cómo quedaría en nuestra clase TesteaCaja:

public static void main(String[] args) {
    Caja<String> cajaDeTexto = new Caja();
    cajaDeTexto.setContenido("Guardando texto en mi caja!");
    System.out.println(cajaDeTexto.sumaContenidoEnCaja("Otra línea"));

    Caja<Integer> cajaDeEdad = new Caja();
    cajaDeEdad.setContenido(30);
    System.out.println(cajaDeEdad.sumaContenidoEnCaja(26));

    Caja<Double> cajaDeValor = new Caja<>();
    cajaDeValor.setContenido(150.50);
    System.out.println(cajaDeValor.sumaContenidoEnCaja(350.50));
    System.out.println(cajaDeValor.sumaContenidoEnCaja("texto"));
}
COPIA EL CÓDIGO
Al ejecutar el código anterior, obtendremos la siguiente salida en nuestro terminal:

Guardando texto en mi caja!

Otra línea

56

501.0

null

Observa que en la última línea del código, al intentar incluir un String "texto" en nuestra cajaDeValor, al ejecutar este código obtuvimos un retorno nulo, ya que solo realizamos la suma si ambos tipos eran iguales.


****************************************************************************************


Las colecciones son estructuras de datos fundamentales en Java que nos permiten almacenar y manipular conjuntos de elementos de manera eficiente. Están implementadas a través de la API de colecciones de Java, que forma parte del paquete java.util. Las colecciones proporcionan una variedad de clases e interfaces para almacenar y organizar datos de diferentes maneras, atendiendo a diversas necesidades y escenarios.

La API de colecciones de Java incluye interfaces, clases abstractas y clases concretas para representar diferentes tipos de colecciones. Algunas de las interfaces principales de colecciones son:

List: Una colección ordenada que permite elementos duplicados. Los elementos se acceden mediante índices.
Set: Una colección que no permite elementos duplicados y normalmente no tiene un orden definido.
Queue: Una colección que representa una cola, donde los elementos se agregan al final y se eliminan del principio.
Map: Una colección de pares clave-valor, donde cada clave es única y mapeada a un valor correspondiente.
Además de estas interfaces, la API de colecciones también incluye varias clases concretas que implementan estas interfaces, como ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap, entre otras.

Una de las interfaces más utilizadas es List. Como se mencionó anteriormente, List es una interfaz que define una secuencia ordenada de elementos, donde cada elemento tiene una posición específica. Al declarar una variable de este tipo, indicamos que trabajaremos con una colección que mantiene el orden de los elementos.

Una de las principales razones para usar List es la flexibilidad que ofrece. Podemos agregar, eliminar y acceder a elementos de manera fácil e intuitiva. Además, también permite la duplicación de elementos, es decir, podemos tener elementos repetidos en la colección. Otra ventaja es la posibilidad de recorrer los elementos de manera secuencial, utilizando bucles de repetición como el for-each, lo que facilita la manipulación de los elementos y la realización de operaciones en masa.

Aquí tienes un ejemplo práctico del uso de List en un código Java:

import java.util.List;
import java.util.ArrayList;

public class EjemploList {
    public static void main(String[] args) {
        // Creando un objeto del tipo List para almacenar números enteros
        List<Integer> numeros = new ArrayList<>();

        // Agregando elementos a la lista
        numeros.add(10);
        numeros.add(20);
        numeros.add(30);

        // Accediendo a elementos de la lista
        System.out.println("Primer elemento: " + numeros.get(0)); // Salida: 10
        System.out.println("Segundo elemento: " + numeros.get(1)); // Salida: 20
        System.out.println("Tercer elemento: " + numeros.get(2)); // Salida: 30

        // Recorriendo los elementos de la lista
        for (Integer numero : numeros) {
            System.out.println(numero);
        }

        // Eliminando un elemento de la lista
        numeros.remove(1); // Elimina el elemento en el índice 1 (20)

        // Verificando el tamaño de la lista
        System.out.println("Tamaño de la lista: " + numeros.size()); // Salida: 2
    }
}
COPIA EL CÓDIGO
Además, Java también tiene otras colecciones como Set y Map. Set es una colección que no permite elementos duplicados, mientras que Map es una colección que asocia claves a valores, permitiendo la recuperación rápida de un elemento a través de su clave.

Las colecciones de Java son extremadamente útiles en diversas situaciones, como almacenar datos en memoria, realizar operaciones de búsqueda, ordenación y filtrado. Nos ayudan a organizar y manipular grandes cantidades de datos de manera eficiente y elegante.

**************************************************************************************

Las constantes juegan un papel importante en la programación, permitiendo que valores fijos e inmutables se almacenen y utilicen a lo largo del código. Son especialmente útiles cuando tenemos valores que no deben modificarse durante la ejecución del programa.

Al declarar una constante, es importante seguir algunas buenas prácticas. La nomenclatura de las constantes debe ser clara y descriptiva, utilizando letras mayúsculas y separando las palabras con guiones bajos (_), siguiendo el patrón conocido como "snake_case". Esto hace que el código sea más legible y comprensible para otros desarrolladores.

En Java, podemos declarar una constante utilizando la palabra clave final. Por ejemplo:

final int AÑO_ACTUAL = 2023;
final String NOMBRE_EMPRESA = "Alura";
COPIA EL CÓDIGO
En este ejemplo, AÑO_ACTUAL y NOMBRE_EMPRESA son constantes que almacenan un valor entero y una cadena, respectivamente. El uso de la palabra clave final indica que estas variables no pueden cambiar su valor después de la asignación inicial.

Además, es una buena práctica declarar las constantes como static si pertenecen a una clase y se comparten entre varios objetos. De esta manera, las constantes pueden accederse directamente a través del nombre de la clase, sin la necesidad de instanciar un objeto.

java

public class EJemploConstantes {
    public static final int AÑO_ACTUAL = 2022;
    public static final String NOMBRE_EMPRESA = "Alura";
}
COPIA EL CÓDIGO
En el ejemplo anterior, las constantes ANHO_ATUAL y NOMBRE_EMPRESA se declaran como static, lo que permite que se acceda directamente a ellas a través de la clase EjemploConstantes. Por ejemplo, así es como podríamos acceder a ellas desde nuestro método main.

java

public class Principal {
    public static void main(String[] args) {
        System.out.println("Yo trabajo en la empresa " + EjemploConstantes.NOMBRE_EMPRESA);
    }
}
COPIA EL CÓDIGO
El uso de constantes aporta beneficios como facilitar el mantenimiento del código, evitar errores de escritura y hacer que el código sea más legible. Además, ayudan a evitar la repetición de valores en diferentes partes del código, promoviendo la consistencia y la reutilización.

Recuerda que las constantes deben utilizarse para valores que no deben modificarse durante la ejecución del programa.

**********************************************************************************************

Las funciones lambda son un recurso muy útil en el lenguaje de programación Java. Pueden ayudar a simplificar nuestro código y hacerlo más fácil de leer y entender. Pero antes de avanzar, comencemos desde el principio.

¿Qué son las funciones Lambda?

Las funciones Lambda, también llamadas funciones anónimas, son una forma de definir funciones que se utilizan con frecuencia solo una vez, directamente en el lugar donde se van a utilizar.

En la programación convencional, normalmente definimos una función en algún lugar de nuestro código y luego la llamamos por su nombre en otro lugar, siempre que necesitemos usarla.

Sin embargo, a veces necesitamos una función que se utilice solo en un lugar de nuestro código. Para estos casos, puede ser más simple y directo definir esta función directamente en el lugar donde se utilizará, sin darle un nombre, es decir, utilizando una función Lambda.

La principal ventaja del uso de funciones lambda es la simplificación del código y la mejora en la legibilidad, ya que la función se define justo donde se usará.

¿Cómo usamos las funciones Lambda en Java?

En Java, una función lambda se define de la siguiente manera:

java

(argumentos) -> { cuerpo-de-la-función }
COPIA EL CÓDIGO
Por ejemplo, podemos definir una función lambda que sume dos números de la siguiente manera:

java

(a, b) -> { return a + b; }
COPIA EL CÓDIGO
Aquí, a y b son los argumentos de nuestra función. El cuerpo de la función, que es el código que se ejecutará cuando se llame a la función, está entre llaves {}. En este caso, el cuerpo de la función es solo una línea que devuelve la suma de a y b.

En Java, las funciones lambda se utilizan generalmente con interfaces funcionales. Una interfaz funcional es una interfaz que contiene solo un único método. La función lambda luego proporciona la implementación de ese único método.

Ejemplos de uso de funciones Lambda

Vamos a un ejemplo concreto para entenderlo mejor. Supongamos que tenemos una lista de números y queremos imprimir solo los números pares de esa lista. Sin el uso de funciones lambda, podríamos hacer algo así:

List<Integer> lista = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

for(Integer i: lista) {
  if(i % 2 == 0) {
    System.out.println(i);
  }
}
COPIA EL CÓDIGO
Pero con el uso de funciones lambda, podemos simplificar este código:

List<Integer> lista = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

lista.stream().filter(i -> i % 2 == 0).forEach(System.out::println);
COPIA EL CÓDIGO
En el código anterior, creamos un stream de nuestra lista, filtramos ese stream para incluir solo los números pares (esto se hace con la función lambda i -> i % 2 == 0), y finalmente usamos el método forEach para imprimir cada elemento del stream filtrado.

Ahora está más claro cómo las funciones Lambda en Java pueden ayudarnos a simplificar nuestro código y hacerlo más legible.

**********************************************************************************************************************************

Aprendimos a iterar para buscar todas las temporadas de una serie específica, a usar las anotaciones @JsonAlias y @JsonIgnoreProperties, a actualizar enlaces durante la iteración y a imprimir listas de las temporadas buscadas de APIs.

Ahora, imaginemos que necesitamos buscar todas las temporadas de una determinada serie de la API. Considerando que ya hemos buscado los datos de la serie y los hemos alimentado en la variable datosSerie, ¿cómo implementaríamos este recurso?

Alternativa correta
List<DatosTemporada> temporadas = new ArrayList<>();
for(int i = 1; i <= datosSerie.totalTemporadas(); i++) {
    json = consumoApi.obtenerDatos("https://www.omdbapi.com/?t="+ serie + "&season=" + i + "&apikey=6585022c");
    DatosTemporada datosTemporada = conversor.obtenerDatos(json, DatosTemporada.class);
    temporadas.add(datosTemporada);
}

temporadas.forEach(System.out::println);

Esta es la implementación correcta para buscar todas las temporadas de una serie específica.

*******************************************************************************************************************************