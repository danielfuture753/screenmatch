JUSTIFICAR TEXTO ALT + Z

****************************************************************

Comparación entre Maven y Gradle

Para entender la diferencia entre Maven y Gradle, primero necesitamos comprender qué son y para qué sirven. Maven y Gradle son herramientas de automatización de construcción y gestión de dependencias muy populares en la comunidad Java. Ayudan a simplificar y organizar el proceso de construcción, prueba e implementación de proyectos Java, haciendo que el desarrollo sea más eficiente.

¿Qué es Maven?

Principales conceptos de Maven:

Gestión de Dependencias: Maven es excelente para gestionar las dependencias de un proyecto. Las dependencias se declaran en el archivo pom.xml y Maven se encarga de descargarlas automáticamente desde el repositorio central de Maven o repositorios personalizados.

Convención sobre Configuración: Maven sigue un conjunto de convenciones, lo que significa que muchas configuraciones están predefinidas y se pueden utilizar directamente sin necesidad de configuración adicional.

Ciclo de Vida Estándar: Maven tiene un ciclo de vida estándar con diferentes fases (por ejemplo, compile, test, package, install, deploy), y cada fase ejecuta una serie de metas. El ciclo de vida estándar permite construir y probar fácilmente su proyecto mediante comandos como mvn compile, mvn test y mvn package.

Repositorio Central: Maven tiene un repositorio central que contiene una amplia variedad de bibliotecas Java listas para ser utilizadas. Este repositorio se puede visualizar en este enlace.

¿Qué es Gradle?

Gradle es otra herramienta de construcción y automatización de proyectos Java que ha ganado popularidad a lo largo de los años. Utiliza un lenguaje de dominio específico (DSL) basado en Groovy o Kotlin para definir la estructura del proyecto y las tareas de construcción.

Principales conceptos de Gradle:

Flexibilidad: Gradle es altamente flexible y le permite definir sus propias tareas de construcción y configurar el proceso de construcción según sus necesidades.

Construcción por Convención: Gradle también sigue algunas convenciones, pero ofrece más libertad que Maven en la forma en que organiza y configura el proyecto.

Gestión de Dependencias: Al igual que Maven, Gradle también gestiona las dependencias del proyecto y puede descargarlas de repositorios remotos.

Compilaciones Incrementales: Gradle está diseñado para realizar compilaciones incrementales, lo que significa que puede construir solo las partes del proyecto que han cambiado desde la última compilación, haciendo que el proceso sea más rápido.

Ahora que tenemos una comprensión básica de qué son Maven y Gradle, veamos sus similitudes, diferencias, ventajas y desventajas.

Similitudes

Tanto Maven como Gradle proporcionan convenciones para la estructura del directorio del proyecto, gestión de dependencias y complementos de construcción. También son ampliamente compatibles con IDEs y herramientas de Integración Continua (CI).

Diferencias

La principal diferencia entre Maven y Gradle es la forma en que gestionan las dependencias y cómo describen la lógica de construcción. Maven utiliza archivos XML para gestionar las dependencias y describe la lógica de construcción mediante complementos, mientras que Gradle utiliza un formato de script y describe la lógica de construcción como código.

Ventajas y Desventajas

Maven es fácil de aprender y tiene un gran ecosistema. La desventaja es que los archivos XML pueden volverse muy grandes y difíciles de gestionar para proyectos complejos.

Gradle, por otro lado, permite scripts de construcción más potentes y es más flexible. Sin embargo, es más difícil de aprender y su ecosistema aún no es tan grande como el de Maven.

La elección entre Maven y Gradle depende de tu proyecto y preferencias. Ambas herramientas son potentes y ampliamente utilizadas, y ambas tienen ventajas y desventajas. Maven es más rígido y sigue un enfoque "opinión sobre configuración", lo que puede ser una ventaja para proyectos más pequeños y simples. Por otro lado, Gradle es más flexible y personalizable, siendo una opción popular para proyectos más grandes y complejos que requieren configuraciones específicas.

En resumen, tanto Maven como Gradle pueden usarse eficientemente para proyectos Java, y la elección dependerá del contexto y las preferencias del equipo de desarrollo.


***************************************************************************************


La interfaz CommandLineRunner es un recurso poderoso dentro del universo de Spring Framework, ampliamente utilizado en el desarrollo de aplicaciones Java. Permite ejecutar alguna acción justo después de la inicialización de nuestra aplicación. Puede ser muy útil, por ejemplo, si queremos cargar algunos datos en nuestra base de datos justo al iniciar nuestra aplicación.

¿Cómo funciona?

Cuando se inicia una aplicación Spring Boot, pueden ocurrir varias operaciones automáticas, como la creación de beans, configuración de la base de datos, entre otras. La apertura para personalizar estas operaciones es limitada, y aquí es donde entra en juego la interfaz CommandLineRunner.

La interfaz CommandLineRunner representa una tarea que se ejecutará después de la inicialización de Spring Boot, es decir, permite definir código que se ejecutará automáticamente cuando se inicie la aplicación.

¿Cómo se usa?

La utilización es bastante simple. En la clase principal de la aplicación, podemos hacer que implemente la interfaz CommandLineRunner. Aquí tienes un ejemplo:

@SpringBootApplication
public class MyCommandLineRunner implements CommandLineRunner {
   
   @Override
    public void run(String... args) throws Exception {
        System.out.println("¡Hola, Mundo!");
    }
}
COPIA EL CÓDIGO
Observa que en el ejemplo anterior, creamos una clase llamada "MyCommandLineRunner" que implementa la interfaz CommandLineRunner. En el método "run", insertamos la acción que deseamos que se ejecute justo después de que la aplicación se inicie, en este caso, simplemente imprimimos "¡Hola, Mundo!".

¿Cuándo usar?

La interfaz CommandLineRunner es muy versátil y se puede utilizar en diversas situaciones. Como se mencionó anteriormente, se puede utilizar para cargar datos en una base de datos. También puede utilizarse para iniciar recursos, como conexiones de red, y para verificar la integridad de ciertos componentes o servicios con los que la aplicación va a interactuar.

Es importante recordar que CommandLineRunner se ejecuta solo en la inicialización de la aplicación, así que no debe utilizarse para tareas que deben ocurrir periódicamente durante el funcionamiento de la aplicación. Para eso, Spring ofrece otras herramientas que serán más adecuadas.

Motivación

Imaginemos una situación en la que tenemos que cargar una gran cantidad de datos en nuestra base de datos tan pronto como nuestra aplicación Spring inicie. Bueno, manualmente esto sería desafiante y llevaría mucho tiempo; sin embargo, la interfaz CommandLineRunner hace que esta tarea sea extremadamente más simple.

Al profundizar en tu conocimiento de Spring, tendrás diversas opciones para optimizar tus aplicaciones y hacer que tu código sea más limpio y eficaz. Spring es un framework que facilita el desarrollo de aplicaciones en Java. Ofrece un modelo de programación completo y simplificado, ocultando muchos de los detalles de bajo nivel. Como resultado, puedes concentrarte en escribir tu código sin preocuparte por una multitud de detalles técnicos. ¡Vamos a sumergirnos juntos en este conocimiento!



En el próximo video, vamos a consumir una API para buscar datos de series. Para hacer esto, crearemos la clase llamada ConsumoAPI dentro de un paquete llamado service. En esta clase, tendremos un método llamado obtenerDatos que devuelve una cadena de texto con el JSON correspondiente a la respuesta de la solicitud.

Dado que este procedimiento es muy similar al que se realizó en el último curso de la formación en Java Orientada a Objetos, lo dejaremos aquí ya disponible para que copies el código de este método y lo pegues en tu clase, con el objetivo de agilizar tus estudios. Sin embargo, si deseas regresar al curso anterior para revisar la explicación, haz clic para acceder al enlace de la lección.

public String obtenerDatos(String url) {
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .build();
        HttpResponse<String> response = null;
        try {
            response = client
                    .send(request, HttpResponse.BodyHandlers.ofString());
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        String json = response.body();
        return json;
    }


    ***************************************************************************************

    @JsonAlias y @JsonProperty son anotaciones de Jackson, una biblioteca Java para procesar JSON, que ayudan a mapear propiedades de clase a campos JSON.

Sin embargo, tienen funciones diferentes. ¿Vamos a conocer mejor cada una de estas anotaciones?

@JsonProperty

Esta anotación se utiliza para definir el nombre de la propiedad JSON asociada al campo Java.

Cuando el JSON se serializa, es decir, se convierte de objetos Java a JSON, el nombre especificado en @JsonProperty se utilizará como la clave para el campo en el JSON de salida. De manera similar, cuando el JSON se deserializa (se convierte de JSON a objetos Java), la biblioteca busca el nombre especificado en @JsonProperty para mapear el valor JSON al campo Java.

Entonces, si deseas usar un nombre diferente en el JSON, puedes utilizar @JsonProperty("nombreEnJson"). Esto es útil, por ejemplo, cuando necesitas trabajar con un JSON que sigue una convención de nomenclatura diferente a la de tu clase Java.

Por ejemplo, si tienes una clase Java con la propiedad "nombreCompleto" y deseas que se mapee al JSON como "nombre", puedes usar @JsonProperty("nombre") para especificar el nombre correcto en el JSON:

java
public class Persona {
    @JsonProperty("nombre")
    private String nombreCompleto;
}
COPIA EL CÓDIGO
@JsonAlias

@JsonAlias se utiliza para definir uno o más alias para el nombre de la propiedad JSON asociada al campo Java.

Al deserializar, @JsonAlias permite que la biblioteca encuentre el valor JSON correspondiente, incluso si el nombre de la propiedad en el JSON no coincide exactamente con el nombre del campo Java.

Esto es útil cuando trabajas con diferentes versiones de un JSON o cuando deseas permitir que una propiedad sea referenciada por nombres diferentes.

Por ejemplo, si tienes una clase Java con la propiedad "nombreCompleto" y el JSON usa "nombre" en su lugar, puedes usar @JsonAlias("nombre") para mapear correctamente la propiedad. De esta manera, tanto "nombreCompleto" como "nombre" serán aceptados al realizar el mapeo:

java
public class Persona {
    @JsonAlias({"nombreCompleto", "nombre"})
    private String nombreCompleto;
}
COPIA EL CÓDIGO
Para obtener más información sobre las anotaciones de Jackson, puedes consultar la documentación oficial aquí: Documentación de Jackson Annotations. https://github.com/FasterXML/jackson



********************************************************************************************

En Java, los genéricos permiten crear clases, interfaces y métodos que pueden trabajar con tipos desconocidos o parámetros genéricos. Proporcionan una forma de escribir código flexible y reutilizable, haciéndolo independiente de tipos específicos y permitiendo que funcione con diferentes tipos de datos.

Para crear una clase o método genérico, necesitas usar parámetros de tipo (tipos genéricos) que se representan entre corchetes angulares <>. Por lo general, usamos letras mayúsculas únicas para representar los tipos genéricos, pero puedes usar cualquier identificador válido en Java. Aquí tienes un ejemplo de una clase genérica llamada Caja, que almacena un valor de un tipo desconocido:

public class Caja<T> {
    private T contenido;

    public T getContenido() {
        return contenido;
    }

    public void setContenido(T contenido) {
        this.contenido = contenido;
    }
}
COPIA EL CÓDIGO
En el ejemplo anterior, podemos crear un objeto del tipo Caja y almacenar cualquier tipo de valor en él. Aquí tienes un ejemplo:

public class TesteaCaja {
    public static void main(String[] args) {
        Caja<String> cajaDeTexto = new Caja();
        cajaDeTexto.setContenido("Guardando texto en mi caja!");

        Caja<Integer> cajaDeEdad = new Caja();
        cajaDeEdad.setContenido(30);

        Caja<Double> cajaDeValor = new Caja<>();
        cajaDeValor.setContenido(150.50);
    }
}
COPIA EL CÓDIGO
Observa que podemos utilizar la clase Caja para incluir valores de diferentes tipos. Para la variable cajaDeTexto, el compilador garantizará que solo se puedan almacenar valores del tipo String. Para la variable cajaDeEdad, el compilador garantizará que solo se puedan almacenar valores del tipo Integer, y así sucesivamente.

Método Genérico

Para crear un método genérico, puedes usar la misma sintaxis con parámetros de tipo entre corchetes angulares. Aquí tienes un ejemplo de un método genérico, que pertenece a la clase Caja y que debería sumar el valor pasado por parámetro al contenido de la caja:

public <T> T sumaContenidoEnCaja(T valor) {
    if (this.contenido instanceof Integer c && valor instanceof Integer i) {
        Integer resultado = c + i;
        return (T) resultado;
    } else if (this.contenido instanceof Double c && valor instanceof Double d) {
        Double resultado = c + d;
        return (T) resultado;
    } else if (this.contenido instanceof String c && valor instanceof String s) {
        String resultado = c + "\n" + s;
        return (T) resultado;
    }

    return null;
}
COPIA EL CÓDIGO
La finalidad del método anterior es realizar la suma entre el contenido actual de la caja (this.contenido) y el valor pasado como parámetro (valor). El método es genérico y puede usarse para diferentes tipos de contenido que pueden sumarse, como Integer, Double y String.

Veamos paso a paso lo que sucede:

public <T> T sumaContenidoEnCaja(T valor) {

El método es genérico y recibe un parámetro valor del tipo genérico T, que es el mismo tipo que se devolverá como resultado de la suma.

Luego, el método comienza con una serie de condicionales if que verifican el tipo del contenido actual de la caja (this.contenido) y el tipo del valor pasado como parámetro (valor).

if (this.contenido instanceof Integer c && valor instanceof Integer i) {
    // Realiza la suma entre los valores y almacena el resultado en una variable
    Integer resultado = c + i;
    // Devuelve el resultado como tipo genérico `T` (en este caso, `Integer`)
    return (T) resultado;
}
COPIA EL CÓDIGO
La verificación se realiza utilizando los operadores instanceof y los operadores de coincidencia de patrones (instanceof con variables de patrón) disponibles a partir de Java 16.

Si el contenido actual (this.contenido) y el valor (valor) son ambos del mismo tipo, se realiza la suma o la concatenación, como en el caso de String. Si el tipo de la variable valor es diferente al tipo del contenido, devolvemos el valor anterior del contenido. Veamos cómo quedaría en nuestra clase TesteaCaja:

public static void main(String[] args) {
    Caja<String> cajaDeTexto = new Caja();
    cajaDeTexto.setContenido("Guardando texto en mi caja!");
    System.out.println(cajaDeTexto.sumaContenidoEnCaja("Otra línea"));

    Caja<Integer> cajaDeEdad = new Caja();
    cajaDeEdad.setContenido(30);
    System.out.println(cajaDeEdad.sumaContenidoEnCaja(26));

    Caja<Double> cajaDeValor = new Caja<>();
    cajaDeValor.setContenido(150.50);
    System.out.println(cajaDeValor.sumaContenidoEnCaja(350.50));
    System.out.println(cajaDeValor.sumaContenidoEnCaja("texto"));
}
COPIA EL CÓDIGO
Al ejecutar el código anterior, obtendremos la siguiente salida en nuestro terminal:

Guardando texto en mi caja!

Otra línea

56

501.0

null

Observa que en la última línea del código, al intentar incluir un String "texto" en nuestra cajaDeValor, al ejecutar este código obtuvimos un retorno nulo, ya que solo realizamos la suma si ambos tipos eran iguales.


****************************************************************************************


Las colecciones son estructuras de datos fundamentales en Java que nos permiten almacenar y manipular conjuntos de elementos de manera eficiente. Están implementadas a través de la API de colecciones de Java, que forma parte del paquete java.util. Las colecciones proporcionan una variedad de clases e interfaces para almacenar y organizar datos de diferentes maneras, atendiendo a diversas necesidades y escenarios.

La API de colecciones de Java incluye interfaces, clases abstractas y clases concretas para representar diferentes tipos de colecciones. Algunas de las interfaces principales de colecciones son:

List: Una colección ordenada que permite elementos duplicados. Los elementos se acceden mediante índices.
Set: Una colección que no permite elementos duplicados y normalmente no tiene un orden definido.
Queue: Una colección que representa una cola, donde los elementos se agregan al final y se eliminan del principio.
Map: Una colección de pares clave-valor, donde cada clave es única y mapeada a un valor correspondiente.
Además de estas interfaces, la API de colecciones también incluye varias clases concretas que implementan estas interfaces, como ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap, entre otras.

Una de las interfaces más utilizadas es List. Como se mencionó anteriormente, List es una interfaz que define una secuencia ordenada de elementos, donde cada elemento tiene una posición específica. Al declarar una variable de este tipo, indicamos que trabajaremos con una colección que mantiene el orden de los elementos.

Una de las principales razones para usar List es la flexibilidad que ofrece. Podemos agregar, eliminar y acceder a elementos de manera fácil e intuitiva. Además, también permite la duplicación de elementos, es decir, podemos tener elementos repetidos en la colección. Otra ventaja es la posibilidad de recorrer los elementos de manera secuencial, utilizando bucles de repetición como el for-each, lo que facilita la manipulación de los elementos y la realización de operaciones en masa.

Aquí tienes un ejemplo práctico del uso de List en un código Java:

import java.util.List;
import java.util.ArrayList;

public class EjemploList {
    public static void main(String[] args) {
        // Creando un objeto del tipo List para almacenar números enteros
        List<Integer> numeros = new ArrayList<>();

        // Agregando elementos a la lista
        numeros.add(10);
        numeros.add(20);
        numeros.add(30);

        // Accediendo a elementos de la lista
        System.out.println("Primer elemento: " + numeros.get(0)); // Salida: 10
        System.out.println("Segundo elemento: " + numeros.get(1)); // Salida: 20
        System.out.println("Tercer elemento: " + numeros.get(2)); // Salida: 30

        // Recorriendo los elementos de la lista
        for (Integer numero : numeros) {
            System.out.println(numero);
        }

        // Eliminando un elemento de la lista
        numeros.remove(1); // Elimina el elemento en el índice 1 (20)

        // Verificando el tamaño de la lista
        System.out.println("Tamaño de la lista: " + numeros.size()); // Salida: 2
    }
}
COPIA EL CÓDIGO
Además, Java también tiene otras colecciones como Set y Map. Set es una colección que no permite elementos duplicados, mientras que Map es una colección que asocia claves a valores, permitiendo la recuperación rápida de un elemento a través de su clave.

Las colecciones de Java son extremadamente útiles en diversas situaciones, como almacenar datos en memoria, realizar operaciones de búsqueda, ordenación y filtrado. Nos ayudan a organizar y manipular grandes cantidades de datos de manera eficiente y elegante.

**************************************************************************************

Las constantes juegan un papel importante en la programación, permitiendo que valores fijos e inmutables se almacenen y utilicen a lo largo del código. Son especialmente útiles cuando tenemos valores que no deben modificarse durante la ejecución del programa.

Al declarar una constante, es importante seguir algunas buenas prácticas. La nomenclatura de las constantes debe ser clara y descriptiva, utilizando letras mayúsculas y separando las palabras con guiones bajos (_), siguiendo el patrón conocido como "snake_case". Esto hace que el código sea más legible y comprensible para otros desarrolladores.

En Java, podemos declarar una constante utilizando la palabra clave final. Por ejemplo:

final int AÑO_ACTUAL = 2023;
final String NOMBRE_EMPRESA = "Alura";
COPIA EL CÓDIGO
En este ejemplo, AÑO_ACTUAL y NOMBRE_EMPRESA son constantes que almacenan un valor entero y una cadena, respectivamente. El uso de la palabra clave final indica que estas variables no pueden cambiar su valor después de la asignación inicial.

Además, es una buena práctica declarar las constantes como static si pertenecen a una clase y se comparten entre varios objetos. De esta manera, las constantes pueden accederse directamente a través del nombre de la clase, sin la necesidad de instanciar un objeto.

java

public class EJemploConstantes {
    public static final int AÑO_ACTUAL = 2022;
    public static final String NOMBRE_EMPRESA = "Alura";
}
COPIA EL CÓDIGO
En el ejemplo anterior, las constantes ANHO_ATUAL y NOMBRE_EMPRESA se declaran como static, lo que permite que se acceda directamente a ellas a través de la clase EjemploConstantes. Por ejemplo, así es como podríamos acceder a ellas desde nuestro método main.

java

public class Principal {
    public static void main(String[] args) {
        System.out.println("Yo trabajo en la empresa " + EjemploConstantes.NOMBRE_EMPRESA);
    }
}
COPIA EL CÓDIGO
El uso de constantes aporta beneficios como facilitar el mantenimiento del código, evitar errores de escritura y hacer que el código sea más legible. Además, ayudan a evitar la repetición de valores en diferentes partes del código, promoviendo la consistencia y la reutilización.

Recuerda que las constantes deben utilizarse para valores que no deben modificarse durante la ejecución del programa.

**********************************************************************************************

Las funciones lambda son un recurso muy útil en el lenguaje de programación Java. Pueden ayudar a simplificar nuestro código y hacerlo más fácil de leer y entender. Pero antes de avanzar, comencemos desde el principio.

¿Qué son las funciones Lambda?

Las funciones Lambda, también llamadas funciones anónimas, son una forma de definir funciones que se utilizan con frecuencia solo una vez, directamente en el lugar donde se van a utilizar.

En la programación convencional, normalmente definimos una función en algún lugar de nuestro código y luego la llamamos por su nombre en otro lugar, siempre que necesitemos usarla.

Sin embargo, a veces necesitamos una función que se utilice solo en un lugar de nuestro código. Para estos casos, puede ser más simple y directo definir esta función directamente en el lugar donde se utilizará, sin darle un nombre, es decir, utilizando una función Lambda.

La principal ventaja del uso de funciones lambda es la simplificación del código y la mejora en la legibilidad, ya que la función se define justo donde se usará.

¿Cómo usamos las funciones Lambda en Java?

En Java, una función lambda se define de la siguiente manera:

java

(argumentos) -> { cuerpo-de-la-función }
COPIA EL CÓDIGO
Por ejemplo, podemos definir una función lambda que sume dos números de la siguiente manera:

java

(a, b) -> { return a + b; }
COPIA EL CÓDIGO
Aquí, a y b son los argumentos de nuestra función. El cuerpo de la función, que es el código que se ejecutará cuando se llame a la función, está entre llaves {}. En este caso, el cuerpo de la función es solo una línea que devuelve la suma de a y b.

En Java, las funciones lambda se utilizan generalmente con interfaces funcionales. Una interfaz funcional es una interfaz que contiene solo un único método. La función lambda luego proporciona la implementación de ese único método.

Ejemplos de uso de funciones Lambda

Vamos a un ejemplo concreto para entenderlo mejor. Supongamos que tenemos una lista de números y queremos imprimir solo los números pares de esa lista. Sin el uso de funciones lambda, podríamos hacer algo así:

List<Integer> lista = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

for(Integer i: lista) {
  if(i % 2 == 0) {
    System.out.println(i);
  }
}
COPIA EL CÓDIGO
Pero con el uso de funciones lambda, podemos simplificar este código:

List<Integer> lista = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

lista.stream().filter(i -> i % 2 == 0).forEach(System.out::println);
COPIA EL CÓDIGO
En el código anterior, creamos un stream de nuestra lista, filtramos ese stream para incluir solo los números pares (esto se hace con la función lambda i -> i % 2 == 0), y finalmente usamos el método forEach para imprimir cada elemento del stream filtrado.

Ahora está más claro cómo las funciones Lambda en Java pueden ayudarnos a simplificar nuestro código y hacerlo más legible.

**********************************************************************************************************************************

Aprendimos a iterar para buscar todas las temporadas de una serie específica, a usar las anotaciones @JsonAlias y @JsonIgnoreProperties, a actualizar enlaces durante la iteración y a imprimir listas de las temporadas buscadas de APIs.

Ahora, imaginemos que necesitamos buscar todas las temporadas de una determinada serie de la API. Considerando que ya hemos buscado los datos de la serie y los hemos alimentado en la variable datosSerie, ¿cómo implementaríamos este recurso?

Alternativa correta
List<DatosTemporada> temporadas = new ArrayList<>();
for(int i = 1; i <= datosSerie.totalTemporadas(); i++) {
    json = consumoApi.obtenerDatos("https://www.omdbapi.com/?t="+ serie + "&season=" + i + "&apikey=6585022c");
    DatosTemporada datosTemporada = conversor.obtenerDatos(json, DatosTemporada.class);
    temporadas.add(datosTemporada);
}

temporadas.forEach(System.out::println);

Esta es la implementación correcta para buscar todas las temporadas de una serie específica.

*******************************************************************************************************************************


**************************************** 11/05/2024 **********************************************************************************

Los streams son una nueva forma de trabajar con colecciones de datos en Java, introducidas a partir de Java 8. Permiten realizar operaciones de manera más eficiente y concisa, utilizando un enfoque funcional.

Un stream es una secuencia de elementos que puede procesarse en paralelo o en serie. Puede crearse a partir de una colección, un array, un archivo, entre otros. A partir de ahí, podemos realizar diversas operaciones en ese stream, como filtrar, mapear, ordenar, entre otras.

Las operaciones intermedias son aquellas que pueden aplicarse en un stream y retornan un nuevo stream como resultado. Estas operaciones no se ejecutan inmediatamente, sino solo cuando se llama a una operación final.

Veamos algunos ejemplos de operaciones intermedias:

Filter: permite filtrar los elementos del stream basándose en una condición. Por ejemplo, podemos filtrar una lista de números para devolver solo los números pares.

List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

List<Integer> numerosPares = numeros.stream()
                                   .filter(n -> n % 2 == 0)
                                   .collect(Collectors.toList());

System.out.println(numerosPares); // Salida: [2, 4, 6, 8, 10]
COPIA EL CÓDIGO
Map: permite transformar cada elemento del stream en otro tipo de dato. Por ejemplo, podemos transformar una lista de cadenas en una lista de sus respectivas longitudes.

List<String> palabras = Arrays.asList("Java", "Stream", "Operaciones", "Intermedias");

List<Integer> tamaños = palabras.stream()
                                .map(s -> s.length())
                                .collect(Collectors.toList());

System.out.println(tamaños); // Salida: [4, 6, 11, 17]
COPIA EL CÓDIGO
Las operaciones finales son aquellas que cierran el stream y devuelven un resultado concreto. Algunas operaciones finales comunes son forEach, collect y count.

Veamos algunos ejemplos de operaciones finales:

ForEach: permite ejecutar una acción en cada elemento de la stream. Por ejemplo, podemos imprimir cada elemento de la lista.

java

List<String> nombres = Arrays.asList("Juan", "Maria", "Pedro", "Ana");

nombres.stream()
     .forEach(nombre -> System.out.println("Hola, " + nombre + "!"));
COPIA EL CÓDIGO
// Salida:

// Hola, Juan!

// Hola, Maria!

// Hola, Pedro!

// Hola, Ana!

Collect: permite recopilar los elementos de la stream en una colección o en otro tipo de dato. Por ejemplo, podemos recopilar los números pares en un conjunto.

List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

Set<Integer> numerosPares = numeros.stream()
                                   .filter(n -> n % 2 == 0)
                                   .collect(Collectors.toSet());

System.out.println(numerosPares); // Salida: [2, 4, 6, 8, 10]
COPIA EL CÓDIGO
En resumen, los streams y sus operaciones intermedias y finales son una forma poderosa de manipular colecciones de datos en Java de manera más eficiente y concisa. Permiten escribir código más legible y expresivo, facilitando el procesamiento y la transformación de datos.

Además de las operaciones intermedias y finales mencionadas, hay muchas otras disponibles, como distinct (que elimina elementos duplicados), limit (que limita el número de elementos de la stream), skip (que salta los primeros elementos del stream), reduce (que combina los elementos de la stream en un único resultado) y muchas más.

Los streams en Java son una herramienta poderosa para la manipulación de colecciones de datos. Las operaciones intermedias permiten filtrar, mapear y ordenar los elementos del stream, mientras que las operaciones finales cierran el stream y devuelven un resultado concreto. Combinando estas operaciones, podemos realizar transformaciones y acciones de manera concisa y eficiente.

***************************************************************************************************************************

Vamos a explorar un tema muy interesante y muy útil en Java: los Constructores Personalizados. Estos son como un comando especial que usamos para crear e inicializar objetos de una clase. El constructor personalizado nos permite definir cómo queremos crear nuestros objetos, permitiéndonos inicializar las propiedades de la clase con los valores que especificamos. En última instancia, esto nos da más control sobre la forma en que se crean nuestros objetos.

¿Cuándo son útiles los Constructores Personalizados?

Consideremos un ejemplo simple. Supongamos que estás creando una clase de Carro en Java, donde cada carro tiene una marca, un modelo y un año.

Sin un constructor personalizado, tendrías que crear un carro de esta manera:

java

Carro miCarro = new Carro();
miCarro.setMarca("Toyota");
miCarro.setModelo("Corolla");
miCarro.setAno(2015);
Esto no es eficiente y también puede dar lugar a errores, ya que nada impide crear un carro sin definir todas las propiedades.
COPIA EL CÓDIGO
Ahora, usando un constructor personalizado:

java

public class Carro {
    private String marca;
    private String modelo;
    private int ano;

    // Constructor personalizado
    public Carro(String marca, String modelo, int ano) {
        this.marca = marca;
        this.modelo = modelo;
        this.ano = ano;
    }
}
COPIA EL CÓDIGO
Ahora puedes crear un nuevo Carro de manera mucho más fácil y segura:

java

Carro miCarro = new Carro("Toyota", "Corolla", 2015);
COPIA EL CÓDIGO
El uso de constructores personalizados asegura que todos los carros que creamos tengan todas las propiedades necesarias definidas.

Posibles problemas al usar Constructores Personalizados A pesar de ser útiles, los constructores personalizados deben usarse correctamente para evitar problemas.

Un problema común es la sobrecarga de constructores, donde tienes muchos constructores en la misma clase. Esto puede hacer que tu código sea confuso y difícil de mantener.

Otro problema puede surgir al utilizar la herencia. Si la clase padre tiene un constructor personalizado, la clase hija debe llamar explícitamente a ese constructor, o el compilador devolverá un error.

Además, si no defines un constructor por defecto (un constructor sin argumentos), Java no creará uno por ti si tienes algún constructor personalizado. Esto puede ser un problema si necesitas crear un objeto sin inicializar ninguna propiedad.

En resumen, los constructores personalizados en Java son una herramienta muy útil en la creación de objetos, asegurando que todas las propiedades necesarias se inicialicen. Sin embargo, deben usarse con cuidado para evitar problemas de sobrecarga y herencia. Como siempre, la mejor estrategia es usar la herramienta adecuada para el trabajo correcto y mantener tu código simple y limpio.

*****************************************************************************************************************************************

La inmutabilidad de los datos es un concepto fundamental en programación que se refiere a la característica de que un objeto o valor no puede ser alterado después de ser creado. Esto aporta varios beneficios, como la seguridad y confiabilidad del código, ya que los datos inmutables no pueden ser modificados o corrompidos accidentalmente.

Además, la inmutabilidad promueve la concurrencia segura en entornos de múltiples hilos, ya que cada hilo puede trabajar con copias de los datos inmutables sin interferir en los demás. La inmutabilidad también hace que el código sea más legible y facilita el mantenimiento, ya que el flujo de información es más claro y predecible.

En Java, podemos crear objetos inmutables utilizando clases finales, atributos finales y métodos que no modifican el estado interno del objeto. Esta práctica es esencial para desarrollar programas más robustos y confiables.

En el video de la lección anterior, vimos que al utilizar streams, una de las operaciones finales nos permite colocar los datos generados en otra lista. También vimos que si utilizamos directamente toList() para este propósito, se genera una lista inmutable. Por lo tanto, cuando necesitamos que la nueva lista pueda modificarse, tenemos que utilizar collect(Collectors.toList()).

En Java, algunas clases nativas ya son inmutables. Algunos ejemplos incluyen:

String: La clase java.lang.String es inmutable. Una vez creada, una instancia de String no puede ser modificada.
Clases Wrapper: Las clases que representan los tipos primitivos, como Integer, Double, Character, etc., también son inmutables.
Enum: Las enumeraciones (enum) en Java son inmutables. Las instancias de un enum se crean solo una vez y no pueden ser modificadas.
Además de las clases nativas, la API de colecciones de Java también ofrece algunas clases inmutables en la clase utilitaria Collections. Estas clases se utilizan para crear colecciones inmutables, como listas, conjuntos y mapas. Algunos ejemplos incluyen:

Collections.unmodifiableList: Crea una lista inmutable a partir de una lista existente.
Collections.unmodifiableSet: Crea un conjunto inmutable a partir de un conjunto existente.
Collections.unmodifiableMap: Crea un mapa inmutable a partir de un mapa existente.
Estas clases te permiten crear versiones inmutables de colecciones existentes, haciéndolas seguras para compartir y evitando la modificación accidental.

Aquí tienes un ejemplo de código:

public class EjemploInmutabilidad {
    public static void main(String[] args) {
        List<String> listaOriginal = new ArrayList<>();
        listaOriginal.add("A");
        listaOriginal.add("B");

        List<String> listaInmutable = Collections.unmodifiableList(listaOriginal);

        // Intentar agregar un elemento a la lista inmutable resultará en una excepción
        listaInmutable.add("C"); // Lanzará UnsupportedOperationException
    }
}

********************************************************************************************************************************


Trabajas desarrollando aplicaciones en un banco digital y una de tus tareas es gestionar y analizar de manera eficiente una enorme cantidad de datos relacionados con las inversiones y saldos de los clientes, con el fin de ofrecerles líneas de crédito adecuadas al saldo que tienen en cuenta.

En este contexto, debes filtrar a los clientes con cuenta corriente y ordenarlos considerando el saldo, en orden descendente, y luego mostrar los cinco clientes con el mayor saldo en cuenta.

Dado que la variable datosClientes ya está poblada con la lista completa de clientes y que los métodos para obtener el tipo de cuenta y el saldo son getTipoCuenta() y getSaldo(), respectivamente, ¿cuál de los siguientes códigos realizará la funcionalidad correctamente?

  datosClientes.stream()
                 .filter(c -> c.getTipoCuenta().equalsIgnoreCase("corriente"))
                 .sorted(Comparator.comparingDouble(Cuenta::getSaldo).reversed())
                 .limit(5);


*************************** 13/05/2024 *******************************************************************************************************+++++++++

Necesitas mostrar una lista de las 10 mejores películas lanzadas en un año determinado. Para ello, tendrás en cuenta el total de visualizaciones, que debe ser mayor o igual a 10 mil, y la calificación de los clientes, que debe ser mayor o igual a 9.4. Considera la clase Pelicula a continuación:

   public class Pelicula {
       private String titulo;
       private Integer totalVisualizacion;
       private Double evaluacion;
       private Integer añoLanzamiento;
       
       // getters, setters y toString() omitidos
   }
COPIA EL CÓDIGO
Dado que List<Pelicula> peliculas ya está poblada con todas las películas y deseas conocer las mejores películas de 2022, ¿cómo realizarías el código para llevar a cabo esta tarea?

   peliculas.stream()
                   .filter(pelicula -> pelicula.getAñoLanzamiento() == 2022)
                   .filter(pelicula -> pelicula.getTotalVisualizacion() >= 10000 && pelicula.getEvaluacion() >= 9.4)
                   .sorted(Comparator.comparingDouble(Pelicula::getEvaluacion).reversed())
                   .limit(10)
                   .forEach(System.out::println);

Creamos un stream y utilizamos dos veces el método filter, uno para seleccionar solo las películas lanzadas en 2022 y otro para filtrar las películas según los criterios establecidos. Luego, usamos sorted para ordenar por la calificación de forma descendente y luego utilizamos el método limit para limitar la lista a 10 películas. Finalmente, usamos la operación forEach para imprimir los datos de la película.

*******************************************************************************************************



Para trabajar con fechas, podemos importar el paquete que contiene varias clases de fecha y hora, el java.time. Esta API de fechas fue introducida en Java 8 con la idea de resolver los problemas de las antiguas clases y facilitar el uso de fechas en Java. ¿Vamos a conocer algunas funcionalidades?

Patrones

Los formatos de fecha y hora se especifican mediante cadenas estándar de fecha y hora. La siguiente tabla muestra la sintaxis estándar que debe utilizarse para el patrón de formato:

Letra	Componente fecha/hora	Ejemplo
G	Designador de era	DC
y	Año	2010; 10
M	Mes en el año	Julio; jul; 10
w	Semana en el año	27
W	Semana en el mes	2
D	Día en el año	189
d	Día en el mes	10
F	Día de la semana en el mes	2
E	Día de la semana	Martes; ter
a	Marcador de am/pm	PM
H	Hora en el día (0-23)	0
k	Hora en el día (1-24)	24
K	Hora en am/pm (0-11)	0
h	Hora en am/pm (1-12)	12
m	Minuto en la hora	30
s	Segundo en el minuto	55
S	Fracción de un segundo	978
Ejemplo:

import java.text.SimpleDateFormat;
import java.util.Date;

public class Fechas {

    public static void main(String[] args) {

        String patron = "E, dd MMM yyyy HH:mm:ss z";
        SimpleDateFormat formatoFecha = new SimpleDateFormat(patron);
        String fecha = formatoFecha.format(new Date());
        System.out.println(fecha);

    }
}
COPIA EL CÓDIGO
Este código producirá:

sáb., 19 nov. 2022 02:58:14 BRT:

Local Date Time

Hora y fecha actuales

LocalDateTime representa una fecha con la hora, visto como año-mes-día-hora-minuto-segundo. El tiempo se representa como yyyy-MM-dd-HH-mm-ss.zzz.

import java.time.LocalDateTime;

public class FechaHorario {

    public static void main(String[] args) {
        LocalDateTime hoy= LocalDateTime.now();
        System.out.println(hoy);
    }
}
COPIA EL CÓDIGO
Resultado:

2022-11-19T04:11:17.108565200

Date Time Formatter

Debes haber notado que los resultados están en formatos con los que no estamos acostumbrados a trabajar. ¡Entonces, podemos trabajar con varios formateadores de fechas existentes!

Ejemplos de formatos de fecha y hora:

Formato Ejemplo

MM/dd/yyyy 19/11/2022

dd-M-yyyy hh:mm:ss 19-11-22 12:07:23

dd MMMM yyyy 19 de noviembre de 2022

dd MMMM yyyy zzzz 19 de noviembre de 2022, Hora estándar de Brasilia

E, dd MMM yyyy HH:mm:ss z Sáb, 19 de noviembre de 2022, 12:07:23 BRT

Además, también podemos cambiar la forma de mostrar el mes. Si usamos letras en cantidades diferentes, el resultado también será consecuentemente diferente. Veamos:

Tipo Por defecto Ejemplo

Mes completo MMMM Septiembre

Mes abreviado MMM Set.

Mes numérico MM 09

Para formatear, utilizaremos DateTimeFormatter. Hay varios ya preparados, pero aún tienes la alternativa de crear tu propio formato en el patrón ya conocido de dd/MM/yyyy hh:mm:ss.

Para hacer esto, simplemente utiliza el método ofPattern. Como vimos en las tablas anteriores, podemos elegir cómo se imprimirá.

DateTimeFormatter formateador = DateTimeFormatter.ofPattern("dd/MM/yyyy hh:mm:ss");
COPIA EL CÓDIGO
Ahora, podemos, a partir de nuestra fecha, en este caso hoy, llamar al método format y pasarle este formateador:

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Formateando {

    public static void main(String[] args) {
        LocalDateTime hoy = LocalDateTime.now();
        System.out.println(hoy);

        DateTimeFormatter formateador = DateTimeFormatter.ofPattern("dd/MM/yyyy hh:mm:ss");
        LocalDateTime ahora = LocalDateTime.now();
        System.out.println(hoy.format(formateador));

    }
}
COPIA EL CÓDIGO
Ahora sí, al ejecutar, obtenemos el resultado:

19/11/2022 04:38:11

*************************************************************************************************************************************


Como hemos estudiado en el curso, los Streams nos permiten manipular colecciones de elementos (como Listas o Conjuntos) de una manera más sofisticada y eficiente que los métodos tradicionales. Son especialmente útiles cuando necesitamos realizar operaciones a gran escala en estos elementos, como filtrar, transformar o agregar.

¿Y qué es la función Peek?

La función "peek" es una operación intermedia de una stream. Una operación intermedia es aquella que procesa los datos del stream pero no la finaliza, es decir, permite que se realicen más operaciones después de ella. La función peek se utiliza para "espiar" los elementos del stream sin alterarlos, lo que puede ser muy útil para la depuración. Esta función recibirá cada elemento del stream y realizará alguna operación con efecto secundario (como imprimir el elemento), pero devolverá el mismo elemento sin cambiar nada.

¿Por qué debería usar esto?

El uso de Streams y la función peek puede ayudarte a escribir códigos más elegantes, fáciles de leer y reducir la posibilidad de errores. Además, pueden hacer que tu código se ejecute más rápido en ciertos casos, ya que los Streams permiten la paralelización de las operaciones, es decir, ejecutar varias operaciones al mismo tiempo.

Ejemplos de código

Ahora veamos un ejemplo simple de cómo podemos usar la función peek con streams. Imagina que tenemos una lista de números y queremos multiplicar cada uno de ellos por 2 y luego sumar los resultados.

List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5);

int suma = numeros.stream()
                .peek(n -> System.out.println("Elemento: " + n))
                .map(n -> n * 2)
                .peek(n -> System.out.println("Contenido después del map: " + n))
                .reduce(0, (total, numero) -> total + numero);

System.out.println("La suma de los números es: " + suma);
COPIA EL CÓDIGO
En este código, creamos una stream con la lista de números, espiamos cada número para imprimirlo (con la función .peek), multiplicamos el valor por dos, volvemos a espiar para verificar el valor de la multiplicación y luego sumamos los resultados.

Así es como aparece en la terminal después de ejecutar la aplicación:

Elemento: 1

Contenido después del map: 2

Elemento: 2

Contenido después del map: 4

Elemento: 3

Contenido después del map: 6

Elemento: 4

Contenido después del map: 8

Elemento: 5

Contenido después del map: 10

La suma de los números es: 30

Esto nos ayuda a asegurarnos de que el proceso se esté realizando correctamente. Aquí podemos ver que la suma de los números 2 + 4 + 6 + 8 + 10 se calculó correctamente, dando como resultado 30. Es decir, la función lambda en nuestro método reduce está haciendo exactamente lo que se planeó. Y pudimos verificar esto con el peek.

Este es solo un ejemplo básico, pero recuerda que la función peek se puede usar en cualquier lugar dentro de tu stream, siempre que desees ver qué elementos están pasando por ese punto.

******************************************************************************************************************

Estás trabajando como persona desarrolladora en Gatito Petshop. El proyecto actual implica el uso de Spring Boot API y Java Streams. Durante tu actividad, recuerdas que la función 'peek' puede ser muy útil para seguir el procesamiento de los streams y facilitar el proceso de depuración. Decides aplicar esta función, pero necesitas recordar cómo funciona.

¿Cómo aplicarías la función 'peek' en una lista de objetos Pet (animales) para imprimir cada elemento mientras se procesa?


   pets.stream()
       .peek(System.out::println)
       .collect(Collectors.toList());

La función 'peek' se utiliza correctamente. Recibe una función lambda como parámetro y actúa sobre cada elemento del stream, en este caso, imprimiéndolos. La operación 'collect' transforma el stream de vuelta en una lista.

***************************************************************************************************************************************************

La programación en Java utiliza Contenedores para almacenar, acceder y manipular datos. Un ejemplo particularmente útil es el Optional, un contenedor especial que puede contener o no un valor. Así que descubramos más sobre el Optional, cómo usarlo y qué prácticas seguir.

¿Qué es el Optional?

Optional es un contenedor de un solo valor introducido en Java 8. Puede contener un valor único o ningún valor. El principal uso de Optional es proporcionar un tipo de retorno alternativo cuando un método puede no devolver un valor.

Usar null es una práctica común, pero puede llevar a errores como NullPointerException. Optional ayuda a evitar estos errores proporcionando una manera más segura de manejar valores que pueden o no estar presentes.

¿Cómo usar el Optional?

Creemos un método que puede devolver un valor null. Sin Optional, podría causar errores no deseados, pero con Optional, es más seguro:

public Optional<String> getNombre() {
    // El nombre puede ser null
    return Optional.ofNullable(nombre);
}
COPIA EL CÓDIGO
Aquí, Optional.ofNullable(nombre) creará un Optional que contiene el valor de nombre si no es null. Si es null, creará un Optional vacío.

Ahora, para acceder al valor dentro de Optional, podemos usar ifPresent y orElse así:

Optional<String> optionalNombre = getNombre();

optionalNombre.ifPresent(System.out::println); // Imprimirá el nombre solo si no es null

String nombre = optionalNombre.orElse("Nombre no disponible"); // Devolverá "Nombre no disponible" si nombre es null
COPIA EL CÓDIGO
Mejores prácticas

Aunque Optional es un aliado útil, hay algunas cosas que deben tenerse en cuenta para usarlo de manera efectiva:

Prefiera el retorno de Optional en lugar de devolver null: Esto hace que sus intenciones sean claras y evita errores.

No use Optional.get() sin Optional.isPresent(): Optional.get() lanzará un error si el valor no está presente. Por lo tanto, es mejor verificar antes si el valor está presente.

No use Optional para campos de la clase o parámetros del método: Optional debe usarse principalmente para retornos de métodos que pueden no tener valor.

Comprender y usar Optional correctamente puede llevar a un código más limpio y menos propenso a errores, así que vale la pena invertir tiempo para aprenderlo.

*****************************************************************************************************************************************************

Trabajar en actividades paralelas es una práctica esencial en programación, ya que permite ejecutar varias tareas simultáneamente, aumentando la eficiencia del código. Una de las formas de lograr la programación paralela en Java es mediante el uso de threads.

Las threads son unidades independientes de ejecución que pueden crearse dentro de un programa. Permiten que diferentes partes del código se ejecuten al mismo tiempo, mejorando el rendimiento y la capacidad de respuesta del programa.

findAny

Una operación útil para trabajar con threads es el método findAny en colecciones de datos. Este método se utiliza para encontrar cualquier elemento que cumpla con una condición específica en una colección. Devuelve un Optional, que puede contener el elemento encontrado o estar vacío si ningún elemento cumple con la condición.

Al utilizar findAny en una colección con threads, cada thread puede buscar un elemento de la colección de manera paralela, haciendo que la búsqueda sea más rápida y eficiente. Es importante destacar que findAny no garantiza que siempre se devolverá el mismo elemento, ya que el orden de búsqueda puede variar entre las threads.

Para utilizar findAny con threads, puedes crear una implementación de Predicate que defina la condición que los elementos deben cumplir. Luego, puedes utilizar el método parallelStream en una colección para crear un stream paralelo y llamar a findAny, pasando el Predicate como argumento. Veamos un ejemplo:

public class EjemploFindAnyParallelStream {
    public static void main(String[] args) {
        List<Integer> numeros = new ArrayList<>();
        for (int i = 1; i <= 100; i++) {
            numeros.add(i);
        }

        // Utilizando parallelStream para encontrar un elemento cualquiera en paralelo
        Optional<Integer> numeroCualquiera = numeros.parallelStream()
                .filter(numero -> numero % 10 == 0) // Filtra los números que son múltiplos de 10
                .findAny();

        if (numeroCualquiera.isPresent()) {
            System.out.println("Encontrado: " + numeroCualquiera.get());
        } else {
            System.out.println("Ningún número encontrado.");
        }
    }
}
COPIA EL CÓDIGO
En este ejemplo, tenemos una lista de números del 1 al 100. Utilizando parallelStream, filtramos los números que son múltiplos de 10 y luego utilizamos findAny para encontrar cualquier elemento que cumpla con esta condición.

Dado que la búsqueda se realiza en paralelo, el resultado puede variar en cada ejecución del programa, ya que diferentes threads pueden encontrar elementos diferentes del stream. La salida en la consola podría ser, por ejemplo:

Encontrado: 70

o

Encontrado: 50

o cualquier otro número que sea múltiplo de 10 dentro de la lista.

Cabe destacar que, para algunos tipos de streams, como streams de listas o arrays, se mantiene el orden de los elementos. Sin embargo, en un stream paralelo, la búsqueda se realizará de manera concurrente y el resultado puede ser cualquier elemento que cumpla con la condición de filtrado. Por lo tanto, en streams paralelos, el método findAny puede ser más útil para obtener cualquier elemento sin garantía de un resultado específico.

*********************************15/05/2024************************************************************

Imagina que eres un analista de datos en Bytebank Banco Digital y se te ha encomendado monitorear el flujo de transacciones bancarias realizadas. El banco utiliza Java Stream API para procesar estos datos. Durante el día, ocurren una gran cantidad de operaciones, y todas se registran en tiempo real.

Utilizando Java Stream API y el concepto de Maps, peek, findFirst y otros recursos, ¿cómo crearías un flujo que filtre las transacciones con valores superiores a 5000, imprima un tipo de registro con peek, busque la primera de estas transacciones encontradas y recolecte los resultados en un Set?

transacciones.stream()
 .filter(t -> t.getValor() > 5000)
 .peek(System.out::println)
 .collect(Collectors.toSet()).stream()
 .findFirst();


Este código compilará y funcionará como se espera. Filtra las transacciones con valores superiores a 5000, imprime un registro de cada una con el método peek, recopila los resultados en un Set y retorna el primer elemento del Set.

****************************************************************************************************************************************

Cuando se trata de generar estadísticas en Java, hay clases que pueden simplificar considerablemente el trabajo. Dos de ellas son DoubleSummaryStatistics e IntSummaryStatistics, que se utilizan para calcular estadísticas básicas en colecciones de valores de tipo double e int, respectivamente.

La clase DoubleSummaryStatistics es una clase de utilidad que permite calcular estadísticas como suma, promedio, valor mínimo y máximo, además del total de elementos en una colección de valores de tipo double. Tiene métodos como getSum(), getAverage(), getMin(), getMax() y getCount(), que devuelven los respectivos valores estadísticos.

De manera similar, la clase IntSummaryStatistics se utiliza para calcular estadísticas básicas en colecciones de valores de tipo int. También tiene métodos como getSum(), getAverage(), getMin(), getMax() y getCount() para obtener las estadísticas deseadas.

Estas clases son especialmente útiles cuando necesitas realizar cálculos estadísticos en una colección de valores. Por ejemplo, si tienes una lista de precios de productos y deseas calcular el promedio, el valor mínimo y el valor máximo, puedes utilizar la clase DoubleSummaryStatistics para obtener esta información de manera simple y eficiente, de manera muy similar a lo que hicimos al obtener estadísticas sobre los episodios con la calificación más alta y más baja, el promedio y el total de elementos considerados en la recopilación de estadísticas.

Para usar estas clases, puedes crear una instancia de ellas y luego recorrer la colección de valores, actualizando las estadísticas según sea necesario. Al final del proceso, puedes llamar a los métodos apropiados para obtener las estadísticas deseadas. Veamos un ejemplo en el que tenemos una lista de estudiantes y queremos obtener datos sobre sus edades.

Para la clase Alumno, tendremos el siguiente código:

public class Alumno {
    private String nombre;
    private LocalDate fechaNacimiento;

    public Alumno(String nombre, LocalDate fechaNacimiento) {
        this.nombre = nombre;
        this.fechaNacimiento = fechaNacimiento;
    }

    public int getEdad() {
        Period periodo = Period.between(fechaNacimiento, LocalDate.now());
        return periodo.getYears();
    }

    // getters, setters y toString omitidos
}
COPIA EL CÓDIGO
Hemos creado un método getEdad(), donde estamos utilizando Period, que al igual que LocalDate, es una clase del paquete java.time, para calcular la edad del estudiante según el día en que se está ejecutando la aplicación.

En nuestra clase principal tendremos el siguiente código:

public class Principal {
    public static void main(String[] args) {
        List<Alumno> alumnos = Arrays.asList(
                new Alumno("Alice", LocalDate.of(2002, 10, 20)),
                new Alumno("Bob", LocalDate.of(1980, 8, 9)),
                new Alumno("Carlos", LocalDate.of(2001, 01, 28)),
                new Alumno("David", LocalDate.of(2003, 05, 12)),
                new Alumno("Eva", LocalDate.of(2005, 12, 03))
        );

        IntSummaryStatistics estadisticas = alumnos.stream()
                .mapToInt(Alumno::getEdad)
                .summaryStatistics();

        // Mostrando las estadísticas
        System.out.println("Edad promedio: " + estadisticas.getAverage());
        System.out.println("Edad mínima: " + estadisticas.getMin());
        System.out.println("Edad máxima: " + estadisticas.getMax());
        System.out.println("Total de alumnos: " + estadisticas.getCount());
    }
}
COPIA EL CÓDIGO
En resumen, las clases DoubleSummaryStatistics e IntSummaryStatistics son herramientas útiles para facilitar la generación de estadísticas básicas en colecciones de valores de tipo double e int. Proporcionan métodos simples y eficientes.

*****************************************************************************************************************************************************************

Java Streams es una característica poderosa que proporciona la capacidad de realizar operaciones de procesamiento de datos complejas de manera eficiente y en paralelo, sobre colecciones, arrays y canales de E/S. Cuando comienzas a comprender mejor Java Streams, te das cuenta de que se puede utilizar de muchas maneras diferentes para hacer que tu código sea más limpio y eficiente. Vamos a profundizar en los usos avanzados de Java Streams y cómo puedes comenzar a integrarlos en tus proyectos.

Usos Avanzados de Java Streams

Cuando trabajamos con Java Streams, a menudo vamos más allá del uso básico y exploramos conceptos más avanzados y complejos. Veamos algunos ejemplos:

1 - Streams Infinitos

Los Streams infinitos, o "infinite Streams", son Streams que no tienen un tamaño definido. Son útiles cuando queremos generar una secuencia de números o valores. Aquí tienes un ejemplo de cómo creamos un Stream infinito con el método iterate:

Stream.iterate(0, n -> n + 1)
     .limit(10)
     .forEach(System.out::println);
COPIA EL CÓDIGO
En el ejemplo anterior, comenzamos con el número 0 y agregamos 1 en cada iteración para generar una secuencia numérica. Utilizamos el método limit() para limitar el Stream infinito a 10 elementos y usamos forEach para imprimirlos.

2 - FlatMap

El método flatMap es una operación intermedia que se utiliza para transformar un Stream de colecciones en un Stream de elementos. Aquí tienes un ejemplo de cómo se usa flatMap:

List<List<String>> lista = List.of(
  List.of("a", "b"),
  List.of("c", "d")
);

Stream<String> stream = lista.stream()
  .flatMap(Collection::stream);

stream.forEach(System.out::println);
COPIA EL CÓDIGO
En este ejemplo, transformamos un Stream de Listas en un Stream de Strings.

3 - Reducción de Streams

Stream.reduce() es una operación terminal que se utiliza para reducir el contenido de un Stream a un único valor.

List<Integer> numeros = List.of(1, 2, 3, 4, 5);
Optional<Integer> resultado = numeros.stream().reduce(Integer::sum);
resultado.ifPresent(System.out::println); // imprime 15
COPIA EL CÓDIGO
En el ejemplo anterior, sumamos todos los números de la lista utilizando el método reduce().

Recuerda que Java Streams es una herramienta poderosa que puede hacer que tu código sea más elegante y eficiente. Sigue practicando y explorando todas las operaciones y métodos disponibles con Java Streams para volverte más hábil en el manejo de datos en tus aplicaciones.

*****************************************************************************************************************************************************************

publicapis.dev/

*****************************************************************************************************************************************************************

